\section{Rotationskorrektur (Janneke)}

Nach dem wir im letzten Kapitel die relative Rotation der Scans berechnet haben wollen wir nun den aktuellen Scans so rotieren, dass er in die Karte mit der richtigen Rotation eingetragen werden kann. Da sich der Roboter bei der Exploration nicht nur im Kreis dreht sondern auch fährt ist das Korrelationsmaximum nicht unbedingt eindeutig. Daher wird die Odometrie verwendet um das richtige Korrelationsmaximum zu finden. Um Fehler auszuschließen haben wir daher zunächst nur die Rotation die wir aus der Odometrie erhalten haben verwendet und den Scan anhand dessen rotiert. Dies hat jedoch nur beim ersten Schritt funktioniert, da wir nicht bedacht haben, dass dir so berechnete Rotation nur zum letzten Scan ist, welcher aber ja bzgl. des davor auch schon rotiert sein kann. Wir mussten also diese relative Rotation in eine globale Rotation bzgl. des ersten Scans umrechnen. Dies haben wir gelöst indem wir einen globalen Offset gespeichert haben der dann um die relative Rotation verändert wurde.

Nachdem wir jetzt sichergestellt hatten, dass es keine Fehler in anderen Teilen der Implementierung mehr gab haben wir ausgehend von der Odometrieschätzung ein lokales Maximum in der Korrelation gesucht. Unser erste Ansatz war es solange nach rechts und links um die Odometrieschätzung zu suchen, bis wir einen Wert gefunden haben, der einen bestimmten Threshold abhängig vom globalen Maximum der Korrelation übersteigt. Zunächst war dieser Threshold 50\% des maximalen Korrelationswerts, später haben wir ihn auf 75\% hochgesetzt. Dies führte jedoch zu Problemen da teilweise nicht das richtige Maximum gefunden wurde. Es wurde schnell klar, das es gerade auf dem echten mit verrauschten Daten sehr schwer sein würde den Threshold gut einzustellen. Daher haben wir uns entschlossen stattdessen einen lokales Maximum in einem bestimmten Suchbereich um die Odometrieschätzung zu suchen. Die Größe des Suchbereichs haben wir zunächst auf 15 Grad in beide Richtungen um die Odometrieschätzung gewählt. Als Parameter lässt sich diese wesentlich einfacher optimieren und ist weniger fehleranfällig als der vorherige Ansatz, wodurch unsere Implementation wesentlich stabiler wurde.

Der Scan wird nun entsprechend des Bins des lokalen Maximum der Korrelation plus globalen Offset rotiert und in die Karte eingetragen. In der Simulation mit einem Roboter der sich nur auf der Stelle rotiert erhalten wir gute Ergebnisse. 